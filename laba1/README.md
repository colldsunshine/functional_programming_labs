# Отчет по лабораторной работе

## Теоретическая часть

### Динамическое программирование
Динамическое программирование — это метод решения сложных задач путем их разбиения на более простые подзадачи. Ключевая идея - решение каждой подзадачи только один раз и сохранение её результата для будущего использования, что позволяет избежать повторных вычисленй

Существует два основных подхода в динамическом программировании:
*   **Нисходящий (Top-Down) с мемоизацией:** Рекурсивный подход, при котором функция вызывает сама себя для решения подзадач, а результаты сохраняются в кэше 

*   **Восходящий (Bottom-Up):** Итеративный подход, при котором все подзадачи решаются последовательно, начиная с самых простых

### Сложность алгоритмов и O-нотация (Big O)
O-нотация (Big O) используется для описания асимптотической сложности алгоритма — того, как время выполнения или объем требуемой памяти растут с увеличением размера входных данных. Она позволяет оценить эффективность алгоритма, абстрагируясь от конкретной машины и среды выполнения 

### Мемоизация в рекурсии
Мемоизация — это техника оптимизации, которая заключается в сохранении (кэшировании) результатов выполнения функций для предотвращения повторных вычислений с теми же входными данными. При рекурсивном решении задачи, перед вычислением результата для какого-либо состояния, проверяется, не был ли он уже вычислен ранее. Если был — возвращается сохраненное значение, что значительно сокращает время выполнения 

## Практическая часть: Решение задач

### Задача 1: Подъем по лестнице (`climbStairs`)

**Описание:** Требуется вычислить количество уникальных способов подняться на лестницу из `n` ступенек, если за один шаг можно преодолеть 1 или 2 ступеньки.

**Решение:** Эта задача является классическим примером на динамическое программирование. Количество способов добраться до `n`-й ступеньки равно сумме способов добраться до `(n-1)`-й и `(n-2)`-й ступенек. Решение использует итеративный (восходящий) подход, вычисляя значения последовательно, что обеспечивает временную сложность O(n)

**Код:**
```python
class task_1:
    def climbStairs(self, n: int) -> int:
        '''
        Вычисляет количество уникальных способов подняться на лестницу из n ступенек,
        если за один шаг можно подняться на 1 или 2 ступеньки.
        Использует итеративный подход с O(n) временем.
        LeetCode: 0 ms, Beats 100.00%
        '''
        if n == 1:
            return 1
        elif n == 2:
            return 2

        prev = 1
        current = 2

        for i in range(3, n + 1):
            next = prev + current
            prev = current
            current = next
        return current
```

### Задача 2: Прыжки по массиву (`jump`)

**Описание:** Дан массив, где каждый элемент представляет максимальную длину прыжка из этой позиции. Необходимо найти минимальное количество прыжков для достижения конца массива.

**Решение:** Применяется жадный алгоритм. На каждом шаге мы находимся в диапазоне `[current_start, current_end]` и ищем максимально далекую позицию `farthest`, в которую можно прыгнуть из этого диапазона. Как только мы достигаем конца текущего диапазона (`i == current_end`), мы совершаем прыжок и обновляем `current_end` до `farthest`. Сложность алгоритма — O(n).

**Код:**
```python
class task_2:
    def jump(self, nums: List[int]) -> int:
        '''
    Вычисляет минимальное количество прыжков, чтобы достичь конца массива,
    где каждый элемент массива представляет максимальную длину прыжка с этой позиции.
    Использует жадный алгоритм с O(n) временем.
    LeetCode: 5 ms, Beats 85.82%
    '''
        jumps = 0
        current_end = 0
        farthest = 0

        for i in range(len(nums) - 1):
            farthest = max(farthest, i + nums[i])

            if i == current_end:
                jumps += 1
                current_end = farthest

        return jumps
```

### Задача 3: Строка треугольника Паскаля (`getRow`)

**Описание:** Требуется вернуть указанную (по индексу `rowIndex`) строку треугольника Паскаля.

**Решение:** Вместо полного построения треугольника, решение эффективно вычисляет элементы строки с использованием формулы для биномиальных коэффициентов C(n, k) = C(n, k-1) * (n - k + 1) / k. Каждый следующий элемент строки вычисляется на основе предыдущего за O(1), что дает общую временную сложность O(rowIndex).

**Код:**
```python
class task_3:
    def getRow(self, rowIndex: int) -> List[int]:
        '''
        Возвращает rowIndex строку треугольника Паскаля (нумерация с 0)
        Использует биномиальные коэффициенты для вычисления за O(n) времени.
        LeetCode: 0 ms, Beats 100.00%
        '''
        row = [1]

        for k in range(rowIndex):
            row.append(row[-1] * (rowIndex - k) // (k + 1))

        return row
```

### Задача 4: Максимальная прибыль от одной транзакции (`maxProfit`)

**Описание:** Найти максимальную прибыль, которую можно получить, совершив не более одной транзакции (одна покупка и одна продажа).

**Решение:** Алгоритм проходит по массиву цен один раз. Он отслеживает минимальную цену, найденную до текущего момента (`min_price`), и вычисляет потенциальную прибыль при продаже по текущей цене. Максимальная из этих прибылей сохраняется. Это решение имеет временную сложность O(n).

**Код:**
```python
class task_4:
    def maxProfit(self, prices: List[int]) -> int:
        '''
        Находит максимальную прибыль от одной
        транзакции (одна покупка + одна продажа)
        Выполняется за O(n) времени.
        LeetCode: 23 ms, Beats 92.86%
        '''
        if not prices:
            return 0

        min_price = prices[0]
        max_profit = 0

        for price in prices[1:]:
            if price < min_price:
                min_price = price
            elif price - min_price > max_profit:
                max_profit = price - min_price

        return max_profit
```

### Задача 5: Максимальная прибыль от нескольких транзакций (`maxProfit`)

**Описание:** Найти максимальную прибыль от неограниченного количества транзакций.

**Решение:** Используется жадный подход. Алгоритм итерирует по ценам и суммирует всю положительную разницу между ценой текущего и предыдущего дня (`prices[i] - prices[i-1]`). Это эквивалентно покупке на локальном минимуме и продаже на следующем за ним локальном максимуме. Сложность решения — O(n).

**Код:**
```python
class task_5:
    def maxProfit(self, prices: List[int]) -> int:
        '''
        Находит максимальную прибыль от неограниченного
        количества транзакций
        Выполняется за O(n) времени
        LeetCode: 0 ms, Beats 100.00%
        '''
        max_profit = 0

        for i in range(1, len(prices)):
            if (prices[i] > prices[i-1]):
                max_profit += prices[i] - prices[i-1]

        return max_profit
```


